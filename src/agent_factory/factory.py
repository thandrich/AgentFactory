from typing import Dict, Any, Optional
import json
import os
from .architect import Architect
from .engineer import Engineer
from .auditor import Auditor
from .utils import setup_logging
from google.adk.agents import ParallelAgent, SequentialAgent
from google.adk.runners import InMemoryRunner

logger = setup_logging("Factory")

class AgentFactory:
    """
    The main factory class that orchestrates the creation of agents.
    """
    
    def __init__(self, model_name: str = "gemini-2.5-flash"):
        self.architect = Architect(model_name=model_name)
        self.engineer = Engineer(model_name=model_name)
        self.auditor = Auditor(model_name=model_name)

    def prepare_workspace(self, goal: str) -> tuple[str, Any]:
        """Prepares the workspace and logging for a new agent."""
        slug = "".join(c if c.isalnum() else "_" for c in goal.lower())[:50]
        workspace_dir = os.path.join(os.getcwd(), "workspaces", slug)
        os.makedirs(workspace_dir, exist_ok=True)
        
        log_file = os.path.join(workspace_dir, "debug.log")
        # Re-setup logger to include file handler
        global logger
        logger = setup_logging("Factory", log_file)
        
        logger.info(f"Starting agent creation for goal: {goal}")
        logger.info(f"Created workspace: {workspace_dir}")
        return workspace_dir, logger

    def save_agent(self, code: str, workspace_dir: str) -> str:
        """Saves the agent code to the workspace."""
        file_path = os.path.join(workspace_dir, "agent.py")
        with open(file_path, "w") as f:
            f.write(code)
        logger.info(f"Agent code saved to: {file_path}")
        return file_path
        
    def create_agent(self, goal: str, max_retries: int = 3, debug_callback: Optional[callable] = None) -> tuple[Optional[str], Optional[Dict[str, Any]]]:
        """
        Creates a multi-agent system based on the goal.
        Returns (generated_code, blueprint) for the LAST agent created (for now), 
        or (None, None) if failed.
        """
        workspace_dir, _ = self.prepare_workspace(goal)
        
        # Helper for debug callback
        def notify_debug(step_name: str, content: Any):
            if debug_callback:
                if not debug_callback(step_name, content):
                    logger.warning(f"Process cancelled by user at step: {step_name}")
                    raise InterruptedError("Cancelled by user")

        try:
            # Step 1: Architect
            notify_debug("Architect: Start", {"goal": goal})
            available_models = ["gemini-2.5-flash", "gemini-1.5-pro"] 
            blueprint = self.architect.design_workflow(goal, available_models)
            notify_debug("Architect: End", blueprint)
            
            if "error" in blueprint:
                logger.error(f"Architect failed: {blueprint['error']}")
                return None, None
                
            logger.info("Blueprint generated successfully.")
            
            agents_to_build = blueprint.get("agents", [])
            context = blueprint.get("end_to_end_context", "")
            
            # Step 2: Create Engineer Agents (Parallel)
            engineer_agents = []
            for agent_def in agents_to_build:
                eng_agent = self.engineer.create_adk_agent(agent_def, context)
                engineer_agents.append(eng_agent)
            
            parallel_engineers = ParallelAgent(
                name="EngineeringTeam",
                sub_agents=engineer_agents
            )
            
            # Step 3: Create Auditor Agent
            auditor_agent = self.auditor.create_adk_agent()
            
            # Step 4: Sequential Flow (Engineers -> Auditor)
            root_agent = SequentialAgent(
                name="FactoryFlow",
                sub_agents=[parallel_engineers, auditor_agent]
            )
            
            runner = InMemoryRunner(agent=root_agent)
            
            notify_debug("Factory: Start Parallel Execution", {"agents": [a.name for a in engineer_agents]})
            
            async def _run_flow():
                return await runner.run_debug(f"Start building agents for goal: {goal}")

            # Execute the flow
            events = asyncio.run(_run_flow())
            
            # Extract results
            # We need to find the code generated by engineers and the review from the auditor
            
            engineer_outputs = {}
            auditor_review = None
            
            print(f"DEBUG: Total events: {len(events)}")
            for event in events:
                print(f"DEBUG: Event source: {getattr(event, 'source', 'NoSource')} Type: {type(event)}")
                if hasattr(event, 'source') and event.source.startswith("Engineer_"):
                    # This is an output from an engineer
                    if hasattr(event, 'content') and event.content and event.content.parts:
                        for part in event.content.parts:
                            if part.text:
                                engineer_outputs[event.source] = part.text
                                
                if hasattr(event, 'source') and event.source == "Auditor":
                     if hasattr(event, 'content') and event.content and event.content.parts:
                        for part in event.content.parts:
                            if part.text:
                                try:
                                    # Clean json
                                    text = part.text.strip()
                                    if text.startswith("```json"): text = text[7:-3]
                                    elif text.startswith("```"): text = text[3:-3]
                                    auditor_review = json.loads(text)
                                except:
                                    pass
            
            print(f"DEBUG: Engineer outputs: {engineer_outputs.keys()}")
            print(f"DEBUG: Auditor review: {auditor_review}")

            notify_debug("Factory: Execution Complete", {"engineer_outputs": list(engineer_outputs.keys()), "review": auditor_review})

            if auditor_review and auditor_review.get("approved"):
                logger.info("Auditor approved the build!")
                
                # Save all files
                saved_files = []
                for agent_name, code in engineer_outputs.items():
                    # agent_name is "Engineer_ActualName"
                    real_name = agent_name.replace("Engineer_", "")
                    file_path = os.path.join(workspace_dir, f"{real_name}.py")
                    
                    # Clean code blocks if present (Engineer might output them)
                    clean_code = code.strip()
                    if clean_code.startswith("```python"): clean_code = clean_code[9:-3]
                    elif clean_code.startswith("```"): clean_code = clean_code[3:-3]
                    
                    with open(file_path, "w") as f:
                        f.write(clean_code)
                    saved_files.append(file_path)
                    
                return saved_files[-1] if saved_files else None, blueprint
            else:
                logger.warning(f"Auditor rejected the build. Issues: {auditor_review.get('issues') if auditor_review else 'Unknown'}")
                return None, None

        except InterruptedError:
            logger.info("Process stopped by user.")
            return None, None
        except Exception as e:
            logger.error(f"Factory execution error: {e}")
            return None, None
